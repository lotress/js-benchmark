// Generated by CoffeeScript 2.3.1
var addCase, argmax, argmin, avg, bench, cases, compare, exec, getStdPersent, printResult, r, readline, run, sampleStd, sum, time, toFixed3;

readline = require('readline');

time = process.hrtime;

compare = (a, b) => {
  return a - b;
};

r = (c) => {
  return (res, x, i) => {
    if (c(res.x, x) < 0) {
      return res;
    } else {
      return {x, i};
    }
  };
};

argmin = (arr, c = compare) => {
  return arr.reduce(r(c), {
    x: arr[0],
    i: 0
  }).i;
};

argmax = (arr, c = compare) => {
  var _c;
  _c = (a, b) => {
    return -c(a, b);
  };
  return argmin(arr, _c);
};

sum = (data) => {
  if (data != null ? data.length : void 0) {
    return data.reduce((sum, x) => {
      return sum + x;
    });
  } else {
    return 0;
  }
};

avg = (data) => {
  var n;
  n = data != null ? data.length : void 0;
  if (n) {
    return parseFloat(sum(data)) / n;
  } else {
    return 0;
  }
};

sampleStd = (data) => {
  var a, n, residualSqr, stdN;
  n = data.length;
  if (n < 2) {
    return 0;
  } else {
    a = avg(data);
    residualSqr = data.map((x) => {
      r = parseFloat(x) - a;
      return r * r;
    });
    stdN = sum(residualSqr);
    return Math.sqrt(stdN / (n - 1));
  }
};

cases = [];

addCase = (description, func) => {
  cases.push({description, func});
  return bench;
};

exec = (item) => {
  var end, start;
  start = time.bigint();
  item.func();
  end = time.bigint();
  return item.samples.push(end - start);
};

toFixed3 = (x) => {
  return x.toFixed(3);
};

getStdPersent = (item) => {
  return toFixed3(100 * item.std / item.avg);
};

printResult = (item) => {
  var result;
  console.log(`Bench ${item.description}:`);
  result = ['', 'average time:', `${toFixed3(item.avg / 1e6)}ms`, `Â±${getStdPersent(item)}%`];
  result.push((function() {
    switch (item.rank) {
      case 1:
        return 'fastest';
      case 2:
        return 'slowest';
    }
  })());
  return console.log(result.join('\t'));
};

run = (samples = 32) => {
  var i, j, ref, times;
  if (!(samples > 0)) {
    throw new Error('Sample counts need > 0');
  }
  cases.forEach((item) => {
    item.rank = 0;
    return item.samples = [];
  });
  for (i = j = 1, ref = samples; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
    readline.clearLine(process.stdout, 0);
    console.log(`Sampling #${i}`);
    cases.forEach(exec);
    readline.moveCursor(process.stdout, 0, -1);
  }
  times = cases.map((item) => {
    return sum(item.samples);
  });
  if (samples > 1) {
    cases[argmin(times)].rank = 1;
    cases[argmax(times)].rank = 2;
  }
  cases.forEach((item, i) => {
    item.avg = parseFloat(times[i]) / samples;
    return item.std = sampleStd(item.samples);
  });
  readline.clearLine(process.stdout, 0);
  cases.forEach(printResult);
  return bench;
};

bench = {addCase, run};

module.exports = bench;
